<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="res/style.css" />
    <link rel="stylesheet" type="text/css" href="res/jquery-ui.min.css" />
    <link rel="stylesheet" type="text/css" href="res/jquery-ui.structure.min.css" />
    <link rel="stylesheet" type="text/css" href="res/jquery-ui.theme.min.css" />

    <script>if (typeof module === 'object') {
        window.module = module;
        module = undefined;
      }</script>

    <!-- normal script imports etc  -->
    <script src="res/jquery-3.3.1.min.js"></script>
    <script src="res/jquery.tablesorter.js"></script>
    <script src="res/jquery.tablesorter.widgets.js"></script>
    <script src="res/jquery.lazy.js"></script>
    <script src="res/jquery-ui.js"></script>
    <script src="res/page-utils.js"></script>

    <!-- Insert this line after script imports -->
    <script>if (window.module)
        module = window.module;</script>

    <script>
      const {dialog} = require('electron').remote;
      const {ipcRenderer} = require('electron');
      const fs = require('fs');
      const DB = require('./modules/DB').getDB();
      const settings = require('./modules/settings').get();
      const Jimp = require('jimp');
      const logger = require('./modules/Log').getLogger(__filename);
      const {webContents, remote} = require('electron');
      const moment = require('moment');
      const momentDurationFormatSetup = require("moment-duration-format");
      const Utils = require('./modules/Utils');

      const ssf = remote.getGlobal("ssf");
      const hardcore = remote.getGlobal("hardcore");

      var hasAreaInfo = false;
      var hasMapMods = false;
      
      async function migrateLeagueDBData() {
        
        let db = require('./modules/DB').getDB();
        
        return new Promise( async (resolve, reject) => {
          
          db.serialize(async () => {
            
            let ver = await getUserVersion();
            if(!ver) {
              logger.info("Error getting DB version");
              resolve(false);
            } else if(ver >= 6) {
              logger.info("DB version >= 6, already migrated");
              resolve(false);
            } else {
              
              $("#loadingText").html("Updating database to new version, please wait...")
              $("#loading").show();
              $("#mainContent").hide();
            
              logger.info("User version < 6, will migrate league info to separate db");
              let leagues = await getLeagues();
              if(!leagues) {
                logger.info("Error getting league list");
                resolve(false);
              }

              for(let i = 0; i < leagues.length; i++) {

                let leagueDB = await require('./modules/DB').initLeagueDB(leagues[i].league);

                let stashes = await getStashes(leagues[i].timestamp, (i < leagues.length - 1) ? leagues[i+1].timestamp : null);
                if(!stashes) {
                  logger.info(`Failed to get stashes for ${leagues[i].league}`);
                } else {
                  let stashStmt = leagueDB.prepare(" insert into stashes(timestamp, items, value) values(?, ?, ?) ");
                  logger.info(`Inserting ${leagues[i].league} stashes`);
                  for(let j = 0; j < stashes.length; j++) {
                    let s = stashes[j];
                    let d = await insertData(stashStmt, [s.timestamp, s.items, s.value]);
                    if(d) {
                      logger.info(`Inserted stash ${s.timestamp} with value ${s.value}`);
                    } else {
                      logger.info(`Error inserting stash ${s.timestamp} with value ${s.value}`);
                    }
                  }
                }

                let rates = await getRates(leagues[i].timestamp.substring(0, 8), (i < leagues.length - 1 ? leagues[i+1].timestamp.substring(0, 8) : null));
                if(!rates) {
                  logger.info(`Failed to get rates for ${leagues[i].league}`);
                } else {
                  let ratesStmt = leagueDB.prepare(" insert into fullrates(date, data) values(?, ?) ");
                  logger.info(`Inserting ${leagues[i].league} rates`);
                  for(let j = 0; j < rates.length; j++) {
                    let s = rates[j];
                    let d = await insertData(ratesStmt, [s.date, s.data]);
                    if(d) {
                      logger.info(`Inserted rates for ${s.date}`);
                    } else {
                      logger.info(`Error inserting rates for ${s.date}`);
                    }
                  }
                }
                
                let charStmt = leagueDB.prepare(" insert into characters values(?)");
                let d = await insertData(charStmt, [ settings.activeProfile.characterName ]);
                if(d) {
                  logger.info(`Inserted charName ${settings.activeProfile.characterName}`);
                } else {
                  logger.info(`Error inserting charName ${settings.activeProfile.characterName}`);
                }

              }

              await setUserVersion(6);

              logger.info("Ended migration");
              
              $("#loadingImg").attr("src", "res/img/loadingcomplete.png");
              $("#loadingText").html("Update complete!");        
              await Utils.sleep(750);
              
            }
            resolve(1);                
                
          });
        });
        
        async function getUserVersion() {
          return new Promise( (resolve, reject) => {
            db.get(" pragma user_version ", (err, row) => {
              if(err) {
                logger.info("Error getting user_version: " + err);
                resolve(false);
              } else {
                resolve(row.user_version);
              }
            });
          });       
        }
        
        async function setUserVersion(ver) {
          return new Promise( (resolve, reject) => {
            db.run(` pragma user_version = ${ver} `, (err, row) => {
              if(err) {
                logger.info("Error setting user_version: " + err);
                resolve(false);
              } else {
                resolve(true);
              }
            });
          });       
        }        

        async function getLeagues() {
          return new Promise( (resolve, reject) => {
            db.all(" select * from leagues order by timestamp ", async (err, leagues) => {
              if(err) {
                logger.info("Error getting league list: " + err);
                resolve(false);
              } else {
                resolve(leagues);
              }
            });
          });       
        }
        
        async function getStashes(t1, t2) {
          let sql = ` select timestamp, items, value from stashes where timestamp > ${t1} `;
          if(t2) {
            sql += ` and timestamp < ${t2} `;
          }
          return new Promise( (resolve, reject) => {
            db.all(sql, async (err, stashes) => {
              if(err) {
                logger.info("Error getting stashes: " + err);
                resolve(false);
              } else {
                resolve(stashes);
              }
            });
          });       
        }
        
        async function getRates(t1, t2) {
          let sql = ` select date, data from fullrates where date >= ${t1} `;
          if(t2) {
            sql += ` and date < ${t2} `;
          }
          return new Promise( (resolve, reject) => {
            db.all(sql, async (err, rates) => {
              if(err) {
                logger.info("Error getting rates: " + err);
                resolve(false);
              } else {
                resolve(rates);
              }
            });
          });       
        }
        
        async function insertData(stmt, data) {
          return new Promise( (resolve, reject) => {
            stmt.run(data, async (err) => {
              if(err) {
                logger.info(`Error inserting data: ${err}`);
                resolve(false);
              } else {
                resolve(true);
              }
            });
          });       
        }
    
      }
      

      $(document).ready(async () => {
        
        await migrateLeagueDBData();
        //return;
        $("#loading").hide();
        $("#mainContent").show();


        if(ssf) {
          $("#totalProfitCell").remove();
        }
        if(hardcore) {
          $("#deathCount").remove();
        }
    
        $("#sidenav").load("sidenav.html");
        $("#messages").load("messages.html");
        $("#lastMapsTable").tablesorter();

        DB.serialize(() => {
          getLastMaps();
        });

        ipcRenderer.on("runProcessed", async (event, runInfo) => {
          
          $("#lastArea").hide();
          
          await Utils.sleep(1000);
          
          DB.get(`
              select mapruns.id, name, level, depth, iiq, iir, packsize, firstevent, lastevent,
              (mapruns.xp - (select xp from mapruns m where m.id < mapruns.id and xp is not null order by m.id desc limit 1)) xpgained,
              gained, kills,
              (select count(1) from events where event_type='slain' and events.id between firstevent and lastevent) deaths
              from areainfo, mapruns
              where mapruns.id = ?
              and ifnull(mapruns.gained, 0) != -1 and ifnull(mapruns.kills, 0) != -1
              and areainfo.id = mapruns.id;
            `, [runInfo.id], (err, row) => {
            if (row) {
              var numberOfShownMaps = $("#numberOfShownMaps").val() || 10;
              if (numberOfShownMaps > 0) {
                if ($("#lastMapsRows tr").length >= numberOfShownMaps) {
                  $("#lastMapsRows tr:last").remove();
                }
              }
              
              Utils.addMapRow({
                table: $("#lastMapsRows"),
                data: row,
                first: true,
                ssf: ssf,
                hardcore: hardcore,
                modal: false
              });
              $("#lastMapsTable").trigger("update");
            } else {
              //console.log(`No row found for ${runInfo.id}, not updating`);
            }
            if(err) {
              logger.info("Error adding map row:");
              logger.info(err);
            }
          });          
        });
        
        $(document).keypress((e) => {
          if(e.ctrlKey && e.shiftKey && e.which === 4) {
            remote.BrowserWindow.getAllWindows()[0].webContents.toggleDevTools();
          }
        });
        
      });
      
      function getLastAreaInfo() {
        DB.get(`
          select * from areainfo where not exists 
          (select 1 from mapruns where mapruns.id = areainfo.id)
          order by id desc limit 1
        `, (err, areaInfo) => {
          if(areaInfo) {
            DB.all("select mod from mapmods where area_id = ? order by cast(id as integer)", [areaInfo.id], (err, mods) => {
              addMapMods(mods);
              addAreaInfo(areaInfo);
              $("#lastArea").show();
            });
          }
        });
      }
      
      function getLastMaps() {
        $("#lastMapsRows").empty();

        var lastMapsQuery = `
            select mapruns.id, name, level, depth, iiq, iir, packsize, firstevent, lastevent,
            (mapruns.xp - (select xp from mapruns m where m.id < mapruns.id and xp is not null order by m.id desc limit 1)) xpgained,
            gained, kills,
            (select count(1) from events where event_type='slain' and events.id between firstevent and lastevent) deaths
            from areainfo, mapruns
            where areainfo.id = mapruns.id
            and ifnull(mapruns.gained, 0) != -1 and ifnull(mapruns.kills, 0) != -1
            order by mapruns.id desc
          `;

        var numberOfShownMaps = $("#numberOfShownMaps").val() || 10;
        if (numberOfShownMaps > 0) {
          lastMapsQuery = lastMapsQuery.concat("limit ", numberOfShownMaps);
        }

        DB.all(lastMapsQuery, (err, rows) => {
          if (rows) {
            rows.forEach(row => {
              Utils.addMapRow({
                table: $("#lastMapsRows"),
                data: row,
                first: false,
                ssf: ssf,
                hardcore: hardcore,
                modal: false
              });
            });
            $("#lastMapsTable").trigger("update");
          }
        });
      }
      
      function addMapMods(mods) {
        $("#mods").empty();
        mods.forEach(m => {
          if(m.mod) {
            m = m.mod;
          }
          $("#mods").append($("<span>", {"class": "mapMod", "html": m + "<br/>"}));
        });
      }
      
      function addAreaInfo(areaInfo) {
        $("#name").html(areaInfo.name);
        $("#level").html(`Monster Level: ${areaInfo.level}`);
        $("#league").html(`${settings.activeProfile.league} League`);
        if (areaInfo.depth) {
          $("#depth").html(`Delve Depth: ${areaInfo.depth}`);
        }
      }
      
    </script>

  <body>
    <div class='sidenav' id='sidenav'></div>
    
    <div id="loading" style="text-align:center;margin-top:15%;display:none;">
      <img id="loadingImg" src="res/img/loading.gif"/>
      <br/>
      <br/>
      <div id="loadingText" style="font-size: smaller"></div>
    </div>
    
    <div id="mainContent">
      <div style="padding:4px;">
        <div class='sectionHeader'>
          Most Recent Maps
          <select id="numberOfShownMaps" onchange="getLastMaps()">
            <option value="10">10</option>
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="0">All</option>
          </select>
        </div>
        <table class='searchResults' id='lastMapsTable' style='width:100%;border-spacing:0px 6px;margin-bottom: 80px;'>
          <thead>
            <tr>
              <th>Date</th>
              <th>Name</th>
              <th>Level</th>
              <th>IIQ</th>
              <th>IIR</th>
              <th>Pack Size</th>
              <th>Time</th>
              <th>XP/hr</th>
              <th id='totalProfitCell'><img src='res/img/c.png'></th>
              <th id='deathCount'>Deaths</th>
              <th>Kills</th>
            </tr>
          </thead>
          <tbody id='lastMapsRows'>
          </tbody>
        </table>      
      </div>
    </div>
      
    <div id="messages" class="messageSection">
    </div>
  </body>
</html>